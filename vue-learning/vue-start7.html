<!DOCTYPE html>
<html>
<head>
	<title>Hello,VUE</title>
	<script src="./vue.js"></script>

</head>
	
<body>

<!-- v-on 监听DOM事件 -->
<div id="example1">
	<button @click="add1">Add 1</button>
	<p>The button above has been clicked {{ counter }} times</p>
</div>
<hr>


<!-- 可以直接绑定方法 也可以内联Javascript语句中的调用方法 -->


<div id="example2">
	<button @click="say('hi')">Say Hi</button>
	<button @click="say('hello')">Say Hello</button>
</div>

<hr>

<!-- 有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法： -->


<div id="example3">
	<button @click="warn('Form cannot be submitted yet', $event)">Submit</button>
</div>

<hr>

<!-- v-on 提供了事件修饰符 -->
<!-- .stop 		阻止冒泡
	 .prevent   阻止事件的本身行为
	 .capture   即内部元素触发的事件先在此处理，然后才交由内部元素进行处理
	 .self      self只响应当前元素自身触发的事件，不会响应经过冒泡触发的事件，并不会阻止冒泡继续向外部触发
	 .once      只执行一次
	 .passive   默认行为 (即滚动行为) 将会立即触发
-->

<script>
	var vm1 = new Vue ({
		el: '#example1',
		data: {
			counter: 0
		},
		methods: {
			add1: function() {
				this.counter += 1
			}
		}
	})

	var vm2 = new Vue ({
		el: '#example2',
		data: {

		},
		methods: {
			say: function(val) {
				alert(val);
			}
		}
	})

	var vm3 = new Vue ({
		el: '#example3',
		data: {

		},
		methods: {
			warn: function(val, env) {

				if (env) {
					console.log(env)
					env.preventDefault()
				}
				alert(val);
			}
		}
	})

</script>

</body>
</html>

